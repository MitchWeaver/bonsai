msg()  { echo "$prompt $@" ; }
die()  { >&2 msg Error "$@" ; exit 1 ; }
warn() { >&2 msg Warning "$@" ; }

usage() {
cat << EOF
$0 pkg mgr

commands:
-----------
add    | -a
del    | -d
search | -s
list   | -l
isinst | -i
count  | -c
EOF
exit
}

# checks if a function is defined
# params: $func_name(s)
defined() {
    for arg ; do
        type $arg | grep 'is.*.function' || return 1
    done > /dev/null
    unset arg
}
# checks if a command exists
# params: $command_name(s)
has() { 
    for arg ; do
        type arg || return 1
    done > /dev/null
    unset arg
}

# check if dir is empty
# params: dir
# return: 0 if true
is_empty() {
    test -e "$1/"* 2> /dev/null
    case $? in
        1)   return 0 ;;
        *)   return 1 ;;
    esac
}

# check if path is a symlink and its target exists
# params: path
# return: 0 if true
test_link() {
    if [ ! -L "$1" ] || [ ! -e "$1" ]; then
        return 1
    fi
}

# cleans $pkgs tree of empty dirs and clears $work
# params: none
clean() {
    sanity_check && rm -rf "$work"/*
    for dir in $(find "$pkgs" -type d ! -wholename "$pkgs" 2> /dev/null) ; do
        rmdir "$dir" 2> /dev/null
    done
    update_db
    unset dir
}

# check variables are still sane before deleting anything
sanity_check() {
    [ "$root" ]     || die "\$root is not set"
    [ "$borehome" ] || die "\$borehome is not set"
    [ "$boredb" ]   || die "\$boredb is not set"
    [ "$pkgs" ]     || die "\$pkgs is not set"
    [ "$ports" ]    || die "\$ports is not set"
    [ "$sources" ]  || die "\$sources is not set"
    [ "$work" ]     || die "\$work is not set"
    [ "$delim" ]    || die "\$delim is not set"
    [ "$gcc" ]      || warn "\$gcc is not set"
    [ "$tcc" ]      || warn "\$tcc is not set"
    [ "$jobs" ]     || jobs=1

    for var in "$root" "$borehome" "$pkgs" "$ports" "$sources" "$work" ; do
        if [ -z "$var" ] || [ "$var" = / ] ; then
            die "config is not sane!"
        fi
    done
    unset var
}

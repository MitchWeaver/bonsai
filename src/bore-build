# runs build() method inside a pkgfile
# params: none
run_build() {
    getcc
    getflags
    GNU_sucks
    # run user defined prebuild(), if exists
    if defined prebuild ; then
        prebuild || die "$name prebuild() failed"
    else # else, try to apply any patches (convenience)
        patch || die "$name generic prebuild() failed"
    fi
    # run user defined build(), if exists
    if defined build ; then
        build || die "$name build() failed"
    else
        { # if build() wasn't defined, try to build generically
          [ -f configure ] && configure
          make
          make install
        } || die "$name generic build() failed"
    fi
    # run user defined postbuild(), if exists
    if defined postbuild ; then
        postbuild || die "$name postbuild() failed"
    fi
}

# return correct $cc
getcc() {
    [ -z "$cc" ] && cc="$gcc"
    [ "$bootstrap_cc" ] && cc="$bootstrap_cc"
}

# convenience function
cc() { $cc "$@" ; }

# macros for convenience when dealing with borked makefiles:
# add includes/libs coming with pkg to search paths
include_pkg_headers() {
    for dir in $(find . -type d) ; do
        PKG_INCLUDES="$PKG_INCLUDES -I$dir"
    done
    CFLAGS="$CFLAGS $PKG_INCLUDES"
}
link_pkg_libs() {
    for dir in $(find . -type d) ; do
        PKG_LIBS="$PKG_INCLUDES -L$dir"
    done
    LDFLAGS="$PKG_LIBS $LDFLAGS"
}

getflags() {
    # If we are bootstrapping, all of our created symlinks
    # will be non-functional. This is because they will be
    # pointing to, for example, "/lib" instead of "$chroot/lib".
    # As a fix for this, we will find and include every $pkg/lib.
    if [ "$chroot_root" ] ; then
        for pkg in $(ls $root/opt) ; do
            [ -d $root/opt/$pkg/lib ] &&
                LDFLAGS="$LDFLAGS -L$root/opt/$pkg/lib"
            if [ -d $root/opt/$pkg/include ] ; then
                CFLAGS="$CFLAGS -I$root/opt/$pkg/include"
                CPPFLAGS="$CPPFLAGS -I$root/opt/$pkg/include"
            fi
        done
    fi

    # note: flag order DOES matter, edit with caution
    LDFLAGS="-static --static -Wl,--gc-sections $LDFLAGS $ldflags"
    CFLAGS="-static --static -fdata-sections -ffunction-sections $CFLAGS $cflags"
    CPPFLAGS="-static --static $CPPFLAGS $cppflags"
    CXXFLAGS="-static --static $CXXFLAGS $cxxflags"
    PKG_CONFIG="pkg-config --static"
}

# convenience function, tries to find all *.patch
# in pkgfile directory and apply them
patch() {
    find . -type f -name "*.patch" | while read -r patch ; do
        command patch -p0 < "$patch"
    done
}

configure() {
    ! $docs  && local _docs="--disable-docs \
                             --disable-gtk-docs \
                             --disable-gtk-docs-html"
    ! $nls   && local _nls='--disable-nls'
    ! $debug && local _debug='--disable-debug --disable-debugger'

    # try to enable as many options as possible
    # if they are allowed in the configure script
    local allowed=""
    local tmp_help=$(mktemp)
    ./configure --help > $tmp_help
    for flag in --static --enable-static --enable-static-link \
                --disable-rpath --disable-option-checking --without-tests \
                $quiet $debug $_nls $_docs ; do
        grep -- "$flag" $tmp_help > /dev/null && \
            allowed="$allowed $flag"
    done
    if grep -- --enable-shared $tmp_help > /dev/null ; then
        allowed="$allowed --disable-shared"
    fi
    rm -f $tmp_help

    CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        CXXFLAGS="$CXXFLAGS" ./configure $allowed "$@" > /dev/null
}

make() {
    ! $mans && local _docs="MANPREFIX=/dev/null"
    $quiet  && local _quiet='-s'
    CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" CXXFLAGS="$CXXFLAGS" \
        command make $makeflags -j$jobs $_docs $_quiet \
        CC="$cc" PREFIX="$opt/$name" prefix="$opt/$name" "$@" > /dev/null
}

# helper to get around all things that GNU does wrong with packaging
GNU_sucks() {
    # GNU programs have the most insane dependency tracking I have ever seen.
    # To check for dependencies, they often simply try to run the program
    # and if it has a -gt 0 exit code, the dependency must not be in $PATH.
    #
    # This breaks all kinds of things, namely if we are running under `set -e`
    # As a workaround, just manually track depedencies -- clear the file.
    [ -f build-aux/missing ] && :> build-aux/missing
    #
    # Some GNU makefiles test certain program flags to see if they
    # are GNU coreutils programs. Some of our minimal programs fail this,
    # causing the makefile to abort unless $ENV variables are set. Absurd.
    # Should a makefile not work correctly with our coreutils, 
    # it will be patched on a per-port basis.
    export GREP=$(which grep) SED=$(which sed) AWK=$(which awk)
}

# remove junk files
# params: $pkgname
clear_junk() {
    [ -d "$opt"/$1/share/info ] && rm -r "$opt"/$1/share/info
    if ! $docs && [ -d "$opt"/$1/share/doc ] ; then
        rm -r "$opt"/$1/share/doc
    fi
    if ! $mans && [ -d "$opt"/$1/share/man ] ; then
        rm -r "$opt"/$1/share/man
    fi
}

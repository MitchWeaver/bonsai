# adds a port
# params: $name
addpkg() {
    is_empty "$ports" && die "addpkg(): no ports found"

    pkg="$pkgs"/"$1"
    name="$1"
    export pkg name

    pkgfile="$ports/$name/pkgfile"

    if isinst "$name" > /dev/null ; then
        msg "port $name is already installed"
        return 1
    fi

    [ -f "$pkgfile" ] || die "addpkg(): could not source $name's pkgfile"
    . "$pkgfile"

#    for dep in $depends $deps ; do
#        isinst "$dep" > /dev/null || die "addpkg(): port $name depends on pkg \"$dep\""
#    done

    [ "$version" ] || version='unknown'
    pkgid="${pkgname}${delim}${version}"

    if [ "$source" ] && [ "$source" != none ] ; then
        get "$source" "$version"
        cd "$work/$name" || die "addpkg(): unable to cd to $work/$pkgid"
        mkdir -p "$pkgs/$name"
        trap 'rmdir $pkgs/$name' INT TERM
    fi

    run_build "$name" || die "$name failed to build"

    if [ -d "$pkgs"/"$name" ] ; then
        link_pkg "$name" || die "$name failed to link"
        clear_junk "$name"
    fi

    add_db "$name" "$version"
    msg "$name installed!"

    sanity_check && [ -d "${work}/$pkgid" ] && rm -rf "${work:?}/$pkgid"
    clean

    trap - INT TERM
    unset pkgname pkgfile pkgid version depends deps
}
# returns all dependencies of a given packages
# in the order in which they need be installed
# param: $name
get_depends() {
    . "$name"
}
# vi:syntax=sh
# shellcheck shell=sh

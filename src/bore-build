# runs build() method inside a pkgfile
# params: pkgname
run_build() {
    getcc

    # if we're using pkg mgr's built in gcc, make sure its valid/existant
    # if its not -- check to see if we're trying to download one
    # ... if not, we cannot compile packages -- error out
    if [ ! -x "$gcc" ] ; then
        case $pkgname in
            *gcc*) ;;
            *tcc*) ;;
            *) die "No compiler toolchain has yet been installed.
         Try \`$PKG_MGR_NAME search gcc\` to find one."
        esac
    fi

    getflags
    GNU_sucks

    # attach default includes/libs
    # note: These cannot just go in $CFLAGS as CFLAGS 
    #       could be overwritten in a makefile.
    gcc="\"$gcc\" -I. -L. -I\"$root\"/include -L\"$root\"/lib $CFLAGS $LDFLAGS"
    tcc="\"$tcc\" -I. -L. -I\"$root\"/include -L\"$root\"/lib -static -w"

    if defined prebuild ; then
        name=$1 prebuild || die "$1 prebuild() failed"
    else # else, try to apply any patches (convenience)
        patch || die "$1 generic prebuild() failed"
    fi
    # run user defined build(), if exists
    if defined build ; then
        name=$1 build || die "$1 build() failed"
    else
        name=$1 generic_build || die "$1 generic_build() failed"
    fi
    # run user defined postbuild(), if exists
    if defined postbuild ; then
        name=$1 postbuild || die "$1 postbuild() failed"
    fi
}

# return $cc if not user specified
getcc() { [ -z "$cc" ] && cc="$gcc" ; }

# convenience function
cc() { $cc "$@" ; }

getflags() {
    LDFLAGS="$LDFLAGS $ldflags"
    CFLAGS="$CFLAGS $cflags"
    CPPFLAGS="$CPPFLAGS $cppflags"
    CXXFLAGS="$CXXFLAGS $cxxflags"
    PKG_CONFIG="$pkgcfgflags"
    PREFIX="$pkgs/$pkgname"
    DESTDIR=""
    BINDIR="$PREFIX/bin"
    INCLUDEDIR="$PREFIX/include"
    LIBDIR="$PREFIX/lib"
    LIBEXECDIR="$PREFIX/libexec"
    MANDIR="$PREFIX/share/man"
    PRESERVEDIR="$root/var/preserve"
}

# convenience function, tries to find all *.patch
# in $work/$pkgname directory and apply them
patch() {
    find . -type f -name "*.patch" | while read -r patch ; do
        command patch -p0 < "$patch" | msg
    done
    unset patch
}

configure() {
    ! $docs  && conf_docs="--disable-docs \
                           --disable-gtk-docs \
                           --disable-gtk-docs-html"
    ! $nls   && conf_nls='--disable-nls'
    ! $debug && conf_debug='--disable-debug --disable-debugger'
    $quiet   && conf_quiet='--silent --quiet'

    # try to enable as many options as possible
    # if they are allowed in the configure script
    allowed=""
    tmp_help=/tmp/$PKG_MGR_NAME-$$.tmp
    ./configure --help > $tmp_help

    for flag in --static --enable-static --enable-static-link \
                --disable-rpath --disable-option-checking --without-tests \
                $conf_quiet $conf_debug $conf_nls $conf_docs ; do
        grep -- "$flag" $tmp_help > /dev/null && allowed="$allowed $flag"
    done

    if grep -- --enable-shared $tmp_help > /dev/null ; then
        allowed="$allowed --disable-shared"
    fi

    rm -f $tmp_help

    CFLAGS="$CFLAGS" \
    LDFLAGS="$LDFLAGS" \
    CPPFLAGS="$CPPFLAGS" \
    CXXFLAGS="$CXXFLAGS" \
    CC="$cc" \
    cc="$cc" \
    DESTDIR="$DESTDIR"
    PREFIX="$PREFIX" \
    prefix="$PREFIX" \
    BINDIR="$BINDIR" \
    INCLUDEDIR="$INCLUDEDIR" \
    LIBDIR="$LIBDIR" \
    LIBEXECDIR="$LIBEXECDIR" \
    MANDIR="$MANDIR" \
    PRESERVEDIR="$PRESERVEDIR" \
        ./configure --prefix="$PREFIX" $allowed "$@" > /dev/null

    return $?
    # unset allowed flag tmp_help conf_docs conf_nls conf_debug conf_quiet
}

make() {
    ! $mans && make_docs="MANPREFIX=/dev/null MANDIR=/dev/null"
    $quiet  && make_quiet='-s'

    CFLAGS="$CFLAGS" \
    LDFLAGS="$LDFLAGS" \
    CPPFLAGS="$CPPFLAGS" \
    CXXFLAGS="$CXXFLAGS" \
        command make $makeflags -j$jobs $make_docs $make_quiet \
        CC="$cc" \
        cc="$cc" \
        DESTDIR="$DESTDIR" \
        PREFIX="$PREFIX" \
        prefix="$PREFIX" \
        BINDIR="$BINDIR" \
        INCLUDEDIR="$INCLUDEDIR" \
        LIBDIR="$LIBDIR" \
        LIBEXECDIR="$LIBEXECDIR" \
        MANDIR="$MANDIR" \
        PRESERVEDIR="$PRESERVEDIR" "$@" > /dev/null

    return $?
    # unset make_quiet make_docs
}

# run if pkgfile doesn't define a custom build()
generic_build() {
    [ -f configure ] && configure
    make
    make install
}

# helper to get around all things that GNU does wrong with packaging
GNU_sucks() {
    # GNU programs have the most insane dependency tracking I have ever seen.
    # To check for dependencies, they often simply try to run the program
    # and if it has a -gt 0 exit code, the dependency must not be in $PATH.
    #
    # This breaks all kinds of things, namely if we are running under `set -e`
    # As a workaround, just manually track depedencies -- clear the file.
    [ -f build-aux/missing ] && :> build-aux/missing
    #
    # Some GNU makefiles test certain program flags to see if they
    # are GNU coreutils programs. Some of our minimal programs fail this,
    # causing the makefile to abort unless $ENV variables are set. Absurd.
    # Should a makefile not work correctly with our coreutils, 
    # it will be patched on a per-port basis.
    export GREP=$(which grep) SED=$(which sed) AWK=$(which awk)
}

# remove junk files
# params: $pkgname
clear_junk() {
    [ -d "$pkgs"/$1/share/info ] && rm -r "$pkgs"/$1/share/info
    if ! $docs && [ -d "$pkgs"/$1/share/doc ] ; then
        rm -r "$pkgs"/$1/share/doc
    fi
    if ! $mans && [ -d "$pkgs"/$1/share/man ] ; then
        rm -r "$pkgs"/$1/share/man
    fi
}

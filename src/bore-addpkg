# adds a port
# params: $name
addpkg() {
    [ "$1" ] || die "addpkg(): no pkg given"
    is_empty "$ports" && die "addpkg(): no ports found"

    for pkg in "$@" ; do
        isinst "$pkg" > /dev/null &&
            die "port $pkg is already installed"
    done

    # check if gcc is functional
    validate_gcc $1

    # params: $name
    load_pkgfile() {
        pkg="$pkgs"/"$1"
        name="$1"
        pkgfile="$ports/$name/pkgfile"
        export pkg name pkgfile

        [ -s "$pkgfile" ] || die "addpkg(): could not source $name's pkgfile"
        . "$pkgfile"
        : "${version:=unknown}"
        pkgid="${name}${delim}${version}"
        export version source pkgid
    }

    # unsets vars as not to persist from pkg to pkg
    unload_pkgfile() {
        unset pkgname pkgfile pkgid version depends deps
        unset -f prebuild build postbuild
    }

    # prompts user y/n to install packages
    # returns 1 on 'n' or bad input
    prompt_user() {
        # prompt user before continuing
        warn "these packages will be installed:"
        # note: $dep_needed is padded by spaces
        printf "\n  %s\n\n" "$main_packages$deps_needed"
        if [ -z "$NO_PROMPT" ] ; then
            msg_no_nl "continue? (y/n): "
            read -r ans
            case "$ans" in
                y|"") ;; # "" is equivalent to user pressing enter
                *) return 1
            esac
            unset ans
        fi
    }

    # adds the given $name
    add() {
        unload_pkgfile
        load_pkgfile "$1"

        if isinst "$name" > /dev/null ; then
            msg "port $name is already installed"
            unload_pkgfile
            return 1
        fi

        case "$source" in
            # if meta package, will not have a source
            # do not try to download
            ""|none) ;;
            *)
                get
                cd "$work/$name" || die "addpkg(): unable to cd to $work/$pkgid"
                mkdir -p "$pkgs/$name"
                trap 'rmdir $pkgs/$name' INT TERM
        esac

        run_build "$name" || die "$name failed to build"

        if [ -d "$pkgs/$name" ] ; then
            linkpkg "$name" || die "$name failed to link"
            clear_junk "$name"
        fi

        add_db "$name" "$version"
        msg "$name installed!"

        sanity_check && [ -d "${work}/$pkgid" ] && rm -rf "${work:?}/$pkgid"
        clean
        trap - INT TERM
        unload_pkgfile
    }

    for pkg in "$@" ; do
        # clear any work from previous build
        rm -rf "${work:?}"

        # grab initial package variables
        load_pkgfile "$pkg"

        # the packages we will install
        main_packages="$main_packages $name"

        # search for dependencies of the initial package
        # the value is stored in $pkgdeps
        pkgdeps "$name"

        # add any deps to $deps_needed
        case "$pkgdeps" in
            # if deps is unset or empty string, there are no deps
            "") ;;
            "* *") ;;
            *) 
                for dep in $pkgdeps ; do
                    isinst "$dep" > /dev/null || 
                        deps_needed="$deps_needed $dep"
                done
        esac
        unload_pkgfile
    done

    # prompt before continuing
    prompt_user || return 1

    # add deps
    for port in $deps_needed ; do
        add "$port"
    done || die "failed to install deps required by $main_packages"

    # add package
    for pkg in $main_packages ; do
        add "$pkg"
    done

    unset -f load_pkgfile unload_pkgfile prompt_user add
}
# vi:syntax=sh
# shellcheck shell=sh

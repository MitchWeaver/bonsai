#!/bin/sh
#
# http://github.com/mitchweaver/bore
#
# package manager for [NAME] Linux
#

die() { >&2 echo "$@" ; exit 1 ; }

usage() {
cat << EOF
bore pkg mgr

commands:
-----------
add    | -a
del    | -d
search | -s
list   | -l
isinst | -i
count  | -c
EOF
exit
}

sortdb() { [ -f "$boredb" ] && sort -o "$boredb" "$boredb" ; }

clean() {
    [ -d "$work" ] && rm -rf "$work"/*
    # remove empty dirs in $opt
    for dir in $(find "$opt" -type d ! -wholename "$opt" 2> /dev/null) ; do
        rmdir "$dir" 2> /dev/null
    done
    sortdb
}

getcc() {
    [ -z "$cc" ] && cc="$gcc"
    [ -n "$bootstrap_cc" ] && cc="$bootstrap_cc"
}

cc() { $cc "$@" ; }

getflags() {
    unset LDFLAGS CFLAGS CPPFLAGS CXXFLAGS PKG_CONFIG
    # If we are bootstrapping, all of our created symlinks
    # will be non-functional. This is because they will be
    # pointing to, for example, "/lib" instead of "$chroot/lib".
    # As a fix for this, we will find and include every $pkg/lib.
    if [ -n "$chroot_root" ] ; then
        for pkg in $(ls $root/opt) ; do
            [ -d $root/opt/$pkg/lib ] &&
                LDFLAGS="$LDFLAGS -L$root/opt/$pkg/lib"
            if [ -d $root/opt/$pkg/include ] ; then
                CPPFLAGS="$CPPFLAGS -I$root/opt/$pkg/include"
                CFLAGS="$CFLAGS -I$root/opt/$pkg/include"
            fi
        done
    else # we are not bootstrapping
        LDFLAGS="-L$root/lib"
        CFLAGS="-isystem $root/include"
        CPPFLAGS="-isystem $root/include"
    fi
    # search for includes in dirs that came with pkg
    # note: this bugs out libressl's readpassphrase.h
    #       for some reason -- please let me know why
    [ $name != libressl ] &&
        for dir in $(find -maxdepth 2 -type d) ; do
            PKG_INCLUDES="$PKG_INCLUDES -I$dir"
        done

    # note: flag order DOES matter, edit with caution
    LDFLAGS="-static --static -Wl,--gc-sections $LDFLAGS $ldflags"
    CFLAGS="-static --static -fdata-sections -ffunction-sections $CFLAGS $cflags $PKG_INCLUDES"
    CPPFLAGS="-static --static $CPPFLAGS $cppflags"
    CXXFLAGS="-static --static $CXXFLAGS $cxxflags"
    PKG_CONFIG="pkg-config --static"
}

patch() { for p ; do command patch -p0 < "$p" > /dev/null ; done ; }

configure() {
    ! $docs  && local _docs="--disable-docs \
                             --disable-gtk-docs \
                             --disable-gtk-docs-html"
    ! $nls   && local _nls='--disable-nls'
    ! $debug && local _debug='--disable-debug --disable-debugger'

    # try to enable as many options as possible
    # if they are allowed in the configure script
    local allowed=""
    local tmp_help=$(mktemp)
    ./configure --help > $tmp_help
    for flag in --static '--enable-static ' --enable-static-link --disable-shared \
                --disable-option-checking --without-tests $quiet $debug $_nls $_docs ; do
        grep -- "$flag" $tmp_help > /dev/null && \
            allowed="$allowed $flag"
    done
    rm -f $tmp_help

    CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        CXXFLAGS="$CXXFLAGS" PREFIX="$opt"/$name prefix="$opt"/$name \
        ./configure --prefix="$opt"/$name $allowed "$@" > /dev/null
}

make() {
    ! $mans && local _docs="MANPREFIX=/dev/null"
    $quiet  && local _quiet='-s'
    command make $makeflags \
        CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        -j$jobs prefix="$opt/$name" PREFIX="$opt/$name" \
        $_docs $_quiet "$@" > /dev/null
}

run_build() {
    getcc
    getflags
    has() { type $1 | grep 'is.*.function' > /dev/null ; return $? ; }
    # run user defined prebuild(), if exists
    if has prebuild ; then
        prebuild || die "$name prebuild() failed"
    fi
    # run build() method inside pkgfile
    if has build ; then
        build || die "$name build() failed"
    else
        { # if build() wasn't defined, try to build generically
          [ -f ./configure ] && configure
          make
          make install
        } || die "$name generic build() failed"
    fi
    # run user defined postbuild(), if exists
    if has postbuild ; then
        postbuild || die "$name postbuild() failed"
    fi
    unset -f has
}

addpkg() {
    name=$1
    pkgfile="$ports"/$name/pkgfile

    if [ -f "$pkgfile" ] ; then
        . "$pkgfile"
    else
        die "Error: can't source $name's pkgfile?"
    fi
    [ "$(ls $boredb | wc -l)" -gt 0 ] || die "no ports found"
    isinst $name > /dev/null && die "port $name is already installed"

    [ -z "$version" ] && version='1.0'
    pkgid="${name}${delim}${version}"
    pkgdir="$work"/"$pkgid"

    # download/extract package
    get "$source"
    cd "$pkgdir" || die "Error: unable to cd to $pkgdir"

    echo ". building $name..."
    mkdir -p $opt/$name

    if run_build ; then
        rm -rf "$pkgdir"
        create_symlinks $name
        clear_junk $name
        echo "$pkgid" >> "$boredb"
        echo "$name installed!"
        clean
    fi
}

# downloads a given url and extracts to $work
get() {
    [ $# -lt 1 ] && die 'get(): no source given'
    clean # clean $work, incase bore was interrupted
    local url="$1"
    local tmp=$(mktemp -d)

    mkdir -p "$pkgdir" "$sources"
    cd "$sources"

    if [ "$version" = git ] ; then
        if [ ! -d "$pkgid" ] ; then
            echo ". cloning $1..."
            git clone $git_opts "$url" $tmp || die "get(): could not clone $url"
            mv -f "$tmp"/* "$work"/"$pkgid"
            $keep_tarballs && cp -rf "$work"/"$pkgid" "$sources"/"$pkgid"
        else
            cp -rf "$sources"/"$pkgid" "$work"
        fi
    else # we are downloading with curl

        if [ ! -f "$pkgid" ] ; then
            echo ". downloading $1..."
            curl -q -L -C - $curl_opts -o "$pkgid" --url "$url" ||
                die "get(): could not download $name"
            cp -f "$pkgid" $tmp
        else
            cp -f "$pkgid" $tmp
        fi

        case $(file $tmp/*) in
            *tgz*)   local ext=tgz   ;;
            *gzip*)  local ext=gz    ;;
            *bzip2*) local ext=bzip2 ;;
            *XZ*)    local ext=xz    ;;
            *) die "get(): could not discern compression type of $name"
        esac

        # decompressors bug out if no extension...
        mv -f $tmp/* $tmp/${name}.${ext}

        case $ext in
            xz)     xz      -d $tmp/* ;;
            bz2)    bunzip2 -d $tmp/* ;;
            gz|tgz) gunzip  -d $tmp/* ;;
            *) die "get(): unknown compression algorithm"
        esac
        [ $? -gt 0 ] && die "get(): failed to decompress $name"

        if file $tmp/* | grep 'tar archive' > /dev/null ; then
            ext=tar.${ext}
            tar -xf $tmp/* -C $tmp/ || 
                die "get(): tar could not extract $pkgid.$ext"       
        fi

        ! $keep_tarballs && rm -f "$sources"/"$pkgid" 

        mv -f $tmp/*/* "$work"/"$pkgid" ||
            die "get(): failed to move unpacked tarball"
    fi
    rm -rf $tmp
    # copy all port's files, except its pkgfile
    for file in $(ls -A "$ports"/"$name"/* | grep -v pkgfile) ; do
        cp -f "$file" "$pkgdir"
    done
}

# creates symlinks for a port
create_symlinks() {
    local name=$1
    cd "$src"
    cd ..
    echo '. creating symlinks...'
    for dir in bin sbin share include etc lib libexec ; do
        # recursively create pkg subdirectories in
        # equivalent /root subdirectories
        # example: $pkg/lib/pkgconfig -> /lib/pkgconfig
        find -P "$opt"/$name/$dir ! -path "*$dir" ! -path "*share/*man*" -mindepth 1 -type d 2> /dev/null | while read -r subdir ; do
            mkdir -p "${subdir#$opt/$name/}"
        done
        # recursively link all files
        # example: $pkg/include/asm/*.h -> /include/asm/*.h
        find -P "$opt"/$name/$dir ! -path "*share/*man*" -mindepth 1 -type f -o -type l 2> /dev/null | while read -r file ; do
            file="${file#$opt/$name/}"
            # important: this is /opt not $opt !
            ln -sfn "/opt/$name/$dir/${file##*/}" ./$file
        done
    done
    $mans && # only link mans if config boolean is true
        if [ -d "$opt"/$name/share/man ] ; then
            for manX in $(seq -f "man%g" -s " " 1 8) ; do
                find -P "$opt"/$name/share/man/$manX ! -path "*/$manX" -mindepth 1 2> /dev/null | while read -r man ; do
                    man="${man#$opt/$name/}"
                    ln -sfn "/opt/$name/share/man/$manX/${man##*/}" "$man"
                done
            done
        fi
}

clear_junk() {
    [ -d "$opt"/$1/share/info ] && rm -r "$opt"/$1/share/info
    if ! $docs && [ -d "$opt"/$1/share/doc ] ; then
        rm -r "$opt"/$1/share/doc
    fi
    if ! $mans && [ -d "$opt"/$1/share/man ] ; then
        rm -r "$opt"/$1/share/man
    fi
}

delpkg() {
    local pkg="$1"

    grep "$pkg" "$boredb" > /dev/null 2>&1 || die "$pkg is not installed"

    [ -d "$opt/$pkg" ] && rm -rf "$opt/$pkg"

    # checks if "$1" is a symlink 
    # and its target still exists
    # test_link() {
    #     if [ -L "$1" ] ; then
    #         [ -e "$1" ] || return 1
    #     fi
    #     return 0
    # }

    # the pkg's data has already been deleted
    # but now we must remove all of its symlinks
    # for dir in bin share include etc lib ; do
    #     for i in `find "$prefix/$dir" ! -path "$prefix/$dir"` ; do
    #         test_link "$i" || rm -f "$i"
    #     done
    # done

    local tmp=$(mktemp)
    sed -e "s/${pkg}${delim}.*//" -e '/^$/d' "$boredb" > $tmp
    cat $tmp > "$boredb"
    rm -f $tmp
    clean

    echo "$pkg deleted"
}

search() {
    [ -n "$1" ] || die 'search: no argument given'
    local results="$(find "$ports" ! -path "$ports" -name *${1}* | sort)"
    [ -n "$results" ] || die "port $1 not found"
    for port in $results ; do
        port=${port##*/}
        echo ${port%.*}
    done
}

isinst() {
    [ -n "$1" ] || die 'isinst: no argument given'
    result=$(grep -i -- "$1" "$boredb")
    if [ -n "$result" ] ; then
        echo "port $result is installed"
        return 0
    else
        echo "port $1 is not installed"
        return 1
    fi
}

loadconfig() {
    # Warning: These options are used when bootstrapping a system.
    #          ... calling them otherwise is not recommended.
    for arg in "$@" ; do
        case "$arg" in
            --root=*) chroot_root="${arg#--root=}" ;;
            --cc=*)   bootstrap_cc="${arg#--cc=}"
        esac
    done

    if [ -z "$chroot_root" ] ; then
        . /src/bore.rc || die "Error: Could not source /src/bore.rc"
    else
        chroot_bore_rc=$(mktemp)
        cp -f "$chroot_root"/src/bore.rc "$chroot_bore_rc" || 
            die "Error: could not load $chroot_src/bore.rc"

        sed -i "s|^root=.*|root=$chroot_root|" "$chroot_bore_rc"

        . "$chroot_bore_rc"
        rm -f "$chroot_bore_rc"
    fi

    [ -z "$jobs" ] && jobs=1
    [ -f "$boredb" ] || :> "$boredb"

    # todo: find a way to loop through config and check every var
    [ -n "$root" ]   || die "loadconfig(): \$root failed to set"
    [ -n "$src" ]    || die "loadconfig(): \$src failed to set"
    [ -n "$opt" ]    || die "loadconfig(): \$opt failed to set"
    [ -n "$bore" ]   || die "loadconfig(): \$bore failed to set"
    [ -n "$boredb" ] || die "loadconfig(): \$boredb failed to set"
    [ -n "$delim" ]  || die "loadconfig(): \$delim failed to set"
}

main() {
    loadconfig "$@"

    while [ $# -gt 0 ] ; do
        case "$1" in
            add|-a)    addpkg $2 ; exit $? ;;
            del|-d)    delpkg $2 ; exit $? ;;
            search|-s) search $2 ; exit $? ;;
            isinst|-i) isinst $2 ; exit $? ;;
            list|-l)   cat "$boredb" ; exit $? ;;
            count|-c)  cat "$boredb" | wc -l | sed 's/ //' ; exit ;;
            --cc=*|--root=*) shift ;; # see above
            *help|-h)  usage ;;
            *) if [ -n "$1" ] ; then
                   addpkg $1
                   exit $?
               else
                   usage
               fi
        esac
    done
}

main "$@"

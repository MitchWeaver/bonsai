#!/bin/sh
#
# http://github.com/mitchweaver/bore
#
# package manager for [NAME] Linux
#

die() { >&2 echo "$@" ; clean ; exit 1 ; }

usage() {
cat << EOF
bore pkg mgr

commands:
-----------
add    | -a
del    | -d
search | -s
list   | -l
isinst | -i
count  | -c
EOF
exit
}

clean() {
    # sanity check
    for var in bore opt src work boredb ; do
        [ -n "$var" ] || exit 1
    done

    rm -rf "$work"/*

    # remove empty dirs in $opt
    for dir in $(find "$opt" -nowarn -type d ! -wholename "$opt") ; do
        rmdir "$dir" 2> /dev/null
    done

    if [ -f "$boredb" ] ; then
        sort "$boredb" -o "$boredb"
    else
        :> "$boredb"
    fi
}

configure() {
    ! $docs && local _docs="--disable-docs \
                      --disable-gtk-docs \
                      --disable-gtk-docs-html"
    ./configure --prefix="$opt"/$name $docs \
        $configure_flags "$@" > /dev/null
}

make() {
    ! $mans && local _docs="MANPREFIX=/dev/null"

    [ -z "$cc" ] && cc="$gcc"
    [ -z "$ldflags" ] && ldflags=""

    command make -j$jobs DESTDIR=$opt/$name PREFIX=/usr \
        CC="$cc" LDFLAGS="$ldflags" $makeflags $_docs "$@" > /dev/null
}

addpkg() {
    pkg="$1"
    pkgfile="$ports"/$pkg/pkgfile

    # sanity checks
    if [ -f "$pkgfile" ] ; then
        . "$pkgfile"
    else
        die "Error: can't source $pkg's pkgfile?"
    fi
    [ "$(ls $boredb | wc -l)" -gt 0 ] ||
        die "no ports available, use 'sync' to fetch some"
    isinst $pkg > /dev/null &&
        die "port $pkg is already installed"


    name="${pkg##*/}"
    [ -z "$version" ] && version='1.0'

    # download/extract package
    get $pkg $version $source
    cd "$work"/"${pkg}${delim}${version}" || die "Error: unable to cd to $work/$pkg"
    echo ". building $pkg..."
    mkdir -p $opt/$pkg

    # run user defined prebuild() if exists
    if type prebuild > /dev/null ; then
        prebuild || die "$pkg prebuild() failed"
    fi
    # run build() method inside pkgfile
    if build ; then
        rm -r "$work"/"${pkg}${delim}${version}"
        echo "${pkg}${delim}${version}" >> "$boredb"
        echo "$pkg installed!"
        clean
    else
        die "$pkg build() failed"
    fi
}

# downloads to $sources and extracts to $work
# params: $name, $version, $source
get() {
    [ $# -lt 3 ] && die 'get(): insufficient arguments'
    local pkg=$1
    local version="$2"
    local url="$3"
    local tmp=$(mktemp -d)

    mkdir -p "$work"/"${pkg}${delim}${version}"
    mkdir -p "$sources"
    cd "$sources"

    if [ "$version" = git ] ; then
        local repo_name="${pkg}${delim}${version}"
        if [ ! -d "$repo_name" ] ; then
            echo ". cloning $1..."
            git clone $git_opts "$url" $tmp ||
                die "get(): could not clone $url"
            mv -f "$tmp"/* "$work"/"$repo_name"
            $keep_tarballs &&
                cp -rf "$work"/"$repo_name" "$sources"/"$repo_name"
        else
            cp -rf "$sources"/"$repo_name" "$work"
        fi
    else # we are downloading with wget
        # check if tarball already downloaded
        if [ ! -f "${pkg}${delim}${version}".* ] ; then
            echo ". downloading $1..."
            wget $wget_opts "$url" -P $tmp ||
                die "wget: could not download $pkg"

            # store backup to be moved to $sources later
            local bkup=$(mktemp -d)
            cp -f $tmp/* $bkup
        else
            cp -f "${pkg}${delim}${version}".* $tmp
        fi
        case $(file $tmp/*) in
            *gzip*)  ext=gz    ;;
            *bzip2*) ext=bzip2 ;;
            *XZ*)    ext=xz    ;;
            *) die "Error: could not discern compression type of $pkg"
        esac

        # decompressors bug out if no extension...
        mv -f $tmp/* $tmp/${pkg}.${ext}

        case $ext in
            xz)   xz      -d $tmp/* ;;
            gz)   gunzip  -d $tmp/* ;;
            bz2)  bunzip2 -d $tmp/* ;;
            *) die "$ext: unknown compression algorithm"
        esac
        [ $? -gt 0 ] && die "$ext: failed to decompress $pkg"

        if file $tmp/* | grep 'tar archive' > /dev/null ; then
            ext=tar.${ext}
            tar -xf $tmp/* -C $tmp/ || \
                die "tar: could not extract ${pkg}${delim}${version}.${ext}"       
        fi

        if $keep_tarballs && [ ! -f "$sources"/"${pkg}${delim}${version}".* ] ; then
            cp -f $bkup/* "$sources"/"${pkg}${delim}${version}.${ext}"
        fi

        mv -f $tmp/*/* "$work"/"${pkg}${delim}${version}" ||
            die "get(): failed to move unpacked tarball"
    fi
}

delpkg() {
    local pkg="$1"

    grep "$pkg" "$boredb" > /dev/null 2>&1 || \
        die "$pkg is not installed"

    [ -d "$opt/$pkg" ] &&
        rm -rf "$opt/$pkg"

    # checks if "$1" is a symlink 
    # and its target still exists
    # test_link() {
    #     if [ -L "$1" ] ; then
    #         [ -e "$1" ] || return 1
    #     fi
    #     return 0
    # }

    # the pkg's data has already been deleted
    # but now we must remove all of its symlinks
    # for dir in bin share include etc lib ; do
    #     for i in `find "$prefix/$dir" ! -path "$prefix/$dir"` ; do
    #         test_link "$i" || rm -f "$i"
    #     done
    # done

    sed -i -e "s/${pkg}${delim}.*//" -e '/^$/d' "$boredb"
    clean

    echo "$pkg deleted"
}

search() {
    [ -n "$1" ] || die 'search: no argument given'
    for p in `find "$ports" ! -path "$ports" \
                -iname *${1}* | sort` ; do
        p=${p##*/}
        p=${p%.*}
        echo $p
    done
    [ -n "$p" ] || die "port $1 not found"
}

isinst() {
    [ -n "$1" ] || die 'isinst: no argument given'
    result=$(grep -i "$1" "$boredb")
    if [ -n "$result" ] ; then
        echo "port $result is installed"
        return 0
    else
        echo "port $result is not installed"
        return 1
    fi
}

main() {
    
    # Warning: These options are used when bootstrapping a system.
    #          ... calling them otherwise is not recommended.
    for arg in "$@" ; do
        case "$arg" in
            --src=*) chroot_src="${arg#--src=}" ;;
            --opt=*) chroot_opt="${arg#--opt=}"
        esac
    done

    if [ -z "$chroot_src" ] ; then
        . /src/bore.rc || die "Error: Could not source /src/bore.rc"
    else
        "$chroot_src"/bore.rc "$chroot_src" "$chroot_opt" || 
            die "Error: Could not source $chroot_src/bore.rc"
    fi

    while [ $# -gt 0 ] ; do
        case "$1" in
            add|-a)    addpkg $2 ; exit $? ;;
            del|-d)    delpkg $2 ; exit $? ;;
            search|-s) search $2 ; exit $? ;;
            isinst|-i) isinst $2 ; exit $? ;;
            list|-l)   cat "$boredb"     ; exit $? ;;
            count|-c)  cat "$db" | wc -l | sed 's/ //' ; exit $? ;;
            *help|-h)  usage ;;
            --opt=*|--src=*) shift ;; # see above
            *) if [ -n "$1" ] ; then
                    addpkg $1
                    exit $?
                else
                    usage
                fi
        esac
    done
}

main "$@"

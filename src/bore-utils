msg()  {
    [ $# -eq 0 ] && read input && set -- "$input"
    printf "%s\n" "$prompt $@"
}
die()  { >&2 msg "Error: $@" ; exit 1 ; }
warn() { >&2 msg "Warning: $@" ; }
separator() { printf '%s\n' '-----------' ; }
newline() { printf '\n' ; }

usage() {
    printf "%s\n\n%s\n" "$PKG_MGR_NAME pkg mgr" \
"commands:
$(separator)
add    | -a
del    | -d
search | -s
list   | -l
isinst | -i
count  | -c"
exit
}

# checks if a function is defined
# params: $func_name(s)
defined() {
    for arg ; do
        type $arg | grep 'is.*.function' || return 1
    done > /dev/null
    unset arg
}
# checks if a command exists
# params: $command_name(s)
has() { 
    for arg ; do
        type $arg || return 1
    done > /dev/null
    unset arg
}

# check if dir is empty
# params: dir
# return: 0 if true, 1 if false or not a dir
is_empty() {
    [ -d "$1" ] || return 1
    [ -e "$1/"* ] 2> /dev/null
    case $? in
        1)   return 0 ;;
        *)   return 1 ;;
    esac
}

# params: $path
# return: 0 if path is a symlink and target exists
test_link() {
    if [ ! -L "$1" ] || [ ! -e "$1" ]; then
        return 1
    fi
}

# posix shell utilities to commonly missing programs
basename() { printf "%s" "${1##*/}" ; }
tac() { sed '1!G;h;$!d' "$@" ; }

# converts "bash#4.8" -> "bash"
pkgid2pkg() { printf '%s' "${1%%$delim*}" ; }

# cleans $pkgs tree of empty dirs and clears $work
# params: none
clean() {
    sanity_check && rm -rf "$work"/*
    for dir in $(find "$pkgs" -type d ! -wholename "$pkgs" 2> /dev/null) ; do
        rmdir "$dir" 2> /dev/null
    done
    update_db
    unset dir
}

# check variables are still sane before deleting anything
sanity_check() {
    [ "$root" ]     || die "\$root is not set"
    [ "$borehome" ] || die "\$borehome is not set"
    [ "$boredb" ]   || die "\$boredb is not set"
    [ "$pkgs" ]     || die "\$pkgs is not set"
    [ "$ports" ]    || die "\$ports is not set"
    [ "$sources" ]  || die "\$sources is not set"
    [ "$work" ]     || die "\$work is not set"
    [ "$delim" ]    || die "\$delim is not set"
    [ "$gcc" ]      || warn "\$gcc is not set"
    [ "$tcc" ]      || warn "\$tcc is not set"
    [ "$jobs" ]     || jobs=1

    for dir in "$borehome" "$pkgs" "$ports" "$sources" "$work" ; do
        [ ! -d "$dir" ] && mkdir "$dir"
    done
    unset var dir
}

# check if all dependencies are met on startup
check_deps() {
    for prog in cat cp find grep ln ls mkdir mv rm rmdir \
                sort sed tar wc file gcc make ; do
        has $prog || die "required program $prog is not available"
    done
    for prog in gzip bzip2 xz ; do
        has $prog || warn "$prog is not installed. Some ports may not extract."
    done
    has git || warn "git is not installed. Some ports may not download."
    has curl || warn "curl is not installed. Some ports may not download."
    has patch || warn "patch is not installed. Some ports may not compile."
    unset prog
}

# create top level dirs in $root, if needed
# params: $root
create_root_dirs() {
    cd "$1"

    ifmkd() { [ -d "$2" ] || mkdir -pm $1 "$2" ; }
    link() {
        [ -L $2 ] && rm -f $2
        ln -sf $1 $2
    }

    for dir in bin boot dev etc home include \
               lib local mnt proc run root share \
               sys var dev/pts var/log var/run src/sources ; do
        ifmkd 0755 $dir
    done

    for dir in dev/shm tmp var/tmp var/preserve ; do
        ifmkd 0775 $dir
    done

    seq -f "man%g" -s " " 1 8 | while read -r manX ; do
        ifmkd 0744 share/man/$manX
    done

    link . usr       # /usr     -> /
    link bin sbin    # /sbin    -> /bin
    link tmp var/tmp # /var/tmp -> /tmp
    link lib libexec # /libexec -> /lib
    unset -f link ifmkd
    unset dir manX
    cd - > /dev/null
}

gccinfo() {
    getflags
    printf "%s\n\n" "version: $($gcc -dumpversion)"
    printf '%s\n\n' "arch: $($gcc -dumpmachine)"
    printf "%s\n\n" "sysroot: $($gcc -print-sysroot)"
    $gcc -print-search-dirs
    $gcc -E -Wp,-v -xc /dev/null
}

#!/bin/sh
#
# http://github.com/mitchweaver/bore
#
# package manager for [NAME] Linux
#

die() { >&2 echo "$@" ; exit 1 ; }

usage() {
cat << EOF
bore pkg mgr

commands:
-----------
add    | -a
del    | -d
search | -s
list   | -l
isinst | -i
count  | -c
EOF
exit
}

sortdb() {
    if [ -f "$boredb" ] ; then
        sort "$boredb" -o "$boredb"
    else
        :> "$boredb"
    fi
}

clean() {
    [ -d "$work" ] && rm -rf "$work"/*
    # remove empty dirs in $opt
    for dir in $(find "$opt" -nowarn -type d ! -wholename "$opt") ; do
        rmdir "$dir" 2> /dev/null
    done
    sortdb
}

getcc() {
    [ -z "$cc" ] && cc="$gcc"
    [ -n "$bootstrap_cc" ] && cc="$bootstrap_cc"
}

cc() { $cc "$@" ; }

getflags() {
    PKG_CONFIG="pkg-config --static"
    CFLAGS="-static $cflags"
    LDFLAGS="-static $ldflags"
    CPPFLAGS="-static -D_GNU_SOURCE $cppflags"
    # If we are bootstrapping, all of our created symlinks
    # will be non-functional. This is because they will be
    # pointing to, for example, "/lib" instead of "$chroot/lib".
    # As a fix for this, we will find and include every $pkg/lib.
    if [ -n "$chroot_root" ] ; then
        for pkg in $(ls $root/opt) ; do
            [ -d $root/opt/$pkg/lib ] &&
                LDFLAGS="$LDFLAGS -L$root/opt/$pkg/lib"
            [ -d $root/opt/$pkg/include ] &&
                CPPFLAGS="$CPPFLAGS -I$root/opt/$pkg/include"
        done
    else
        LDFLAGS="$LDFLAGS -L$root/lib"
        CPPFLAGS="$CPPFLAGS -I$root/include"
    fi
}

patch() { for p ; do command patch -p0 < "$p" > /dev/null ; done ; }

configure() {
    ! $docs  && local _docs="--disable-docs \
                      --disable-gtk-docs \
                      --disable-gtk-docs-html"
    ! $nls   && local _nls='--disable-nls'
    ! $debug && local _debug='--disable-debug --disable-debugger'

    # try to enable as many options as possible
    # if they are allowed in the configure script
    local allowed=""
    for flag in --static --enable-static-link $quiet $debug $_nls $_docs \
                --disable-option-checking ; do
        ./configure --help | grep -- "$flag" > /dev/null && \
            allowed="$allowed $flag"
    done

    CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        PREFIX="$opt"/$pkg_name prefix="$opt"/$pkg_name \
        ./configure $allowed --prefix="$opt"/$pkg_name \
        $configure_flags "$@" -- > /dev/null
}

make() {
    ! $mans && local _docs="MANPREFIX=/dev/null"
    $quiet  && local _quiet='-s'
    command make $makeflags \
        CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        -j$jobs prefix="$opt/$pkg_name" PREFIX="$opt/$pkg_name" \
        $_docs $_quiet "$@" -- > /dev/null
}

run_build() {
    getcc
    getflags
    # run user defined prebuild(), if exists
    if type prebuild > /dev/null ; then
        prebuild || die "$pkg prebuild() failed"
    fi
    # run build() method inside pkgfile
    build || die "$pkg build() failed"
    # run user defined postbuild(), if exists
    if type postbuild > /dev/null ; then
        postbuild || die "$pkg postbuild() failed"
    fi
}

addpkg() {
    pkg_name=$1
    pkgfile="$ports"/$pkg_name/pkgfile

    if [ -f "$pkgfile" ] ; then
        . "$pkgfile"
    else
        die "Error: can't source $pkg_name's pkgfile?"
    fi
    [ "$(ls $boredb | wc -l)" -gt 0 ] || die "no ports found"
    isinst $pkg_name > /dev/null && die "port $pkg_name is already installed"

    [ -z "$version" ] && version='1.0'
    pkgid="${pkg_name}${delim}${version}"
    pkgdir="$work"/"$pkgid"

    # download/extract package
    get "$source"
    cd "$pkgdir" || die "Error: unable to cd to $pkgdir"

    echo ". building $pkg_name..."
    mkdir -p $opt/$pkg_name

    if run_build ; then
        rm -r "$pkgdir"
        create_symlinks $pkg_name
        echo "$pkgid" >> "$boredb"
        echo "$pkg_name installed!"
        clean
    fi
}

# downloads a given url and extracts to $work
get() {
    [ $# -lt 1 ] && die 'get(): no source given'
    clean # clean $work, incase bore was interrupted
    local url="$1"
    local tmp=$(mktemp -d)

    mkdir -p "$pkgdir" "$sources"
    cd "$sources"

    if [ "$version" = git ] ; then
        if [ ! -d "$pkgid" ] ; then
            echo ". cloning $1..."
            git clone $git_opts "$url" $tmp || die "get(): could not clone $url"
            mv -f "$tmp"/* "$work"/"$pkgid"
            $keep_tarballs && cp -rf "$work"/"$pkgid" "$sources"/"$pkgid"
        else
            cp -rf "$sources"/"$pkgid" "$work"
        fi
    else # we are downloading with wget
        if [ ! -f "$pkgid".* ] ; then
            echo ". downloading $1..."
            wget $wget_opts "$url" -P $tmp ||
                die "wget: could not download $pkg_name"

            # store backup to be moved to $sources later
            local bkup=$(mktemp -d)
            cp -f "$tmp/"* $bkup
        else
            cp -f "$pkgid".* $tmp
        fi
        case $(file $tmp/*) in
            *gzip*)  ext=gz    ;;
            *bzip2*) ext=bzip2 ;;
            *XZ*)    ext=xz    ;;
            *) die "Error: could not discern compression type of $pkg_name"
        esac

        # decompressors bug out if no extension...
        mv -f $tmp/* $tmp/${pkg_name}.${ext}

        case $ext in
            xz)   xz      -d $tmp/* ;;
            gz)   gunzip  -d $tmp/* ;;
            bz2)  bunzip2 -d $tmp/* ;;
            *) die "$ext: unknown compression algorithm"
        esac
        [ $? -gt 0 ] && die "$ext: failed to decompress $pkg_name"

        if file $tmp/* | grep 'tar archive' > /dev/null ; then
            ext=tar.${ext}
            tar -xf $tmp/* -C $tmp/ || 
                die "tar: could not extract $pkgid.$ext"       
        fi

        if $keep_tarballs && [ ! -f "$sources"/"$pkgid".* ] ; then
            cp -f $bkup/* "$sources"/"$pkgid".$ext
        fi

        mv -f $tmp/*/* "$work"/"$pkgid" ||
            die "get(): failed to move unpacked tarball"
        rm -rf $bkup
    fi
    rm -rf $tmp
    # copy all port's files, except its pkgfile
    for file in $(ls -A "$ports"/"$pkg_name"/* | grep -v pkgfile) ; do
        cp -f "$file" "$pkgdir"
    done
}

# creates symlinks for a port
create_symlinks() {
    pkg_name=$1
    echo '. creating symlinks...'
    # sym link all $opt/$pkg_name/$dir to the /$dir
    for dir in bin sbin share include etc lib lib32 lib64 usr ; do
        for i in $(find "$opt/$pkg_name/$dir" ! -path "*$dir" \
                ! -path "*$pkg_name/share/man" \
                ! -path "*$pkg_name/lib/pkgconfig" \
                -maxdepth 1 2> /dev/null) ; do
            [ -e "$i" ] || continue
            i="$(basename $i)"
            cd "$src"
            cd ..
            # important: this is /opt not $opt !
            ln -sn "/opt/$pkg_name/$dir/$i" "./$dir/$i"
        done
    done

    if [ -d "$opt"/$pkg_name/lib/pkgconfig ] ; then
        for i in $(find "$opt"/$pkg_name/lib/pkgconfig \
                ! -path "*/lib/pkgconfig" 2> /dev/null) ; do
            [ -e "$i" ] || continue
            i=$(basename $i)
            cd "$src"
            cd ..
            ln -sn "/opt/$pkg_name/lib/pkgconfig/$i" "./lib/pkgconfig/$i"
        done
    fi

    $mans &&
        if [ -d "$opt"/$pkg_name/share/man ] ; then
            for manX in $(seq -f "man%g" -s " " 1 8) ; do
                for i in $(find "$opt/$pkg_name/share/man/$manX" \
                        ! -path "*/$manX" 2> /dev/null) ; do
                    [ -e "$i" ] || continue
                    i=$(basename $i)
                    cd "$src"
                    cd ..
                    ln -sn "/opt/$pkg_name/share/man/$manX/$i" "./share/man/$manX/$i"
                done
            done
        fi
}

delpkg() {
    local pkg="$1"

    grep "$pkg" "$boredb" > /dev/null 2>&1 || die "$pkg is not installed"

    [ -d "$opt/$pkg" ] && rm -rf "$opt/$pkg"

    # checks if "$1" is a symlink 
    # and its target still exists
    # test_link() {
    #     if [ -L "$1" ] ; then
    #         [ -e "$1" ] || return 1
    #     fi
    #     return 0
    # }

    # the pkg's data has already been deleted
    # but now we must remove all of its symlinks
    # for dir in bin share include etc lib ; do
    #     for i in `find "$prefix/$dir" ! -path "$prefix/$dir"` ; do
    #         test_link "$i" || rm -f "$i"
    #     done
    # done

    sed -i -e "s/${pkg}${delim}.*//" -e '/^$/d' "$boredb"
    clean

    echo "$pkg deleted"
}

search() {
    [ -n "$1" ] || die 'search: no argument given'
    for p in `find "$ports" ! -path "$ports" -iname *${1}* | sort` ; do
        p=${p##*/}
        p=${p%.*}
        echo $p
    done
    [ -n "$p" ] || die "port $1 not found"
}

isinst() {
    [ -n "$1" ] || die 'isinst: no argument given'
    result=$(grep -i "$1" "$boredb")
    if [ -n "$result" ] ; then
        echo "port $result is installed"
        return 0
    else
        echo "port $1 is not installed"
        return 1
    fi
}

loadconfig() {
    # Warning: These options are used when bootstrapping a system.
    #          ... calling them otherwise is not recommended.
    for arg in "$@" ; do
        case "$arg" in
            --root=*) chroot_root="${arg#--root=}" ;;
            --cc=*)   bootstrap_cc="${arg#--cc=}"
        esac
    done

    if [ -z "$chroot_root" ] ; then
        . /src/bore.rc || die "Error: Could not source /src/bore.rc"
    else
        chroot_bore_rc=$(mktemp)
        cp -f "$chroot_root"/src/bore.rc "$chroot_bore_rc" || 
            die "Error: could not load $chroot_src/bore.rc"

        sed -i "s|^root=.*|root=$chroot_root|" "$chroot_bore_rc"

        . "$chroot_bore_rc"
        rm -f "$chroot_bore_rc"
    fi
    # todo: find a way to loop through config and check every var
    [ -n "$root" ]   || die "loadconfig(): \$root failed to set"
    [ -n "$src" ]    || die "loadconfig(): \$src failed to set"
    [ -n "$opt" ]    || die "loadconfig(): \$opt failed to set"
    [ -n "$bore" ]   || die "loadconfig(): \$bore failed to set"
    [ -n "$boredb" ] || die "loadconfig(): \$boredb failed to set"
    [ -n "$delim" ]  || die "loadconfig(): \$delim failed to set"
}

main() {
    loadconfig "$@"

    sortdb

    while [ $# -gt 0 ] ; do
        case "$1" in
            add|-a)    addpkg $2 ; exit $? ;;
            del|-d)    delpkg $2 ; exit $? ;;
            search|-s) search $2 ; exit $? ;;
            isinst|-i) isinst $2 ; exit $? ;;
            list|-l)   cat "$boredb" ; exit $? ;;
            count|-c)  cat "$db" | wc -l | sed 's/ //' ; exit ;;
            --cc=*|--root=*) shift ;; # see above
            *help|-h)  usage ;;
            *) if [ -n "$1" ] ; then
                   addpkg $1
                   exit $?
               else
                   usage
               fi
        esac
    done
}

main "$@"

# -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
# Package Installation   http://github.com/bonsai-linux/bonsai
# -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

add() {
    # check if pkg is already installed (-f to force)
    case $1 in
        -f) isinst "$1" && warn "$1 is already installed" ; shift ;;
         *) isinst "$1" && die  "$1 is already installed"
    esac

    # load package variables into the environment
    loadpkgfile "$1"

    # clear old working directory should it exist
    rm -rf -- "$workdir" 2>/dev/null ||:
    mkdir -p "$workdir"

    # download sources and copy to $workdir
    if [ -f "$portdir"/sources ] ; then
        mkdir -p "$SOURCES/$pkgstring"
        get
    fi

    # build
    run_build

    # after successful build, create the symlinks in the root
    linkpkg

    # remove our build dir
    rm -rf -- "$workdir"

    msg "$name installed"

    # remove package variables from the environment
    unloadpkgfile
}

# 1. downloads all remote files to $SOURCES/$pkgstring if needed
# 2. copies files, both local and remote, as specified to $workdir
get() {
    while read -r file sum ; do
        case $file in
            *'://'*)
                # must be a remote file
                msg "downloading ${file##*/}"
                outfile=$SOURCES/$pkgstring/${file##*/}
                [ -f "$outfile" ] || dl "$file" >"$outfile"
                chksum "$outfile" "$sum"
                extract "$outfile" "$workdir"
                ;;
            *)
                # no protocol specified, must be a local file.
                # checksum it just as we would a remote file, then copy it
                chksum "$portdir/$file" "$sum"
                # if file is in a dir, first create the dir
                [ -d "$portdir/${file%%/*}" ] && mkdir -p "$workdir/${file%%/*}"
                cp -f "$portdir/$file" "$workdir/$file"
        esac
    done <"$portdir"/sources
}

dl() {
    curl -#fLC - --retry 3 -o - "$1"

# -*-* downloading with netcat currently work in progress -*-*-*
# domain=${1#*://}
# domain=${domain%%/*}
# file=${1#*://}
# file=${file#$domain}

# nc -v -C -w 9999 "$domain" "${2:-80}" <<EOF | sed '/.*\r$/d'
# GET $file HTTP/1.1
# Host: $domain
# Connection: close

# EOF
# -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
}

# args: $file $sum
chksum() {
    msg "comparing checksums for ${1##*/}"
    sum=$(sha512sum "$1")
    [ "$2" = "${sum%% *}" ] || die 'checksum mismatch!'
}

extract() {
    case $1 in
        *.tar.*|*.tgz|*.txz|*.tbz)
            decompress "$1" | tar -C "$2" -xf -

            # Ensure extracted tar files are in the top level of $2.
            #
            # note: Ee must use a loop here as glob will match '.'
            #       in some shells even when not in the directory,
            #       which will cause 'mv' to prematurely error.
            for dot in "$2"/*/.* ; do
                mv "$dot" "$2"/ 2>/dev/null ||:
            done
            mv "$2"/*/*  "$2"/ 2>/dev/null ||:

            # remove any empty dirs we may have created
            rmdir "$2"/* 2>/dev/null ||:
            ;;
        *.xz|*.gz|*.bz2)
            out=${1##*/}
            decompress "$1" >"$2/${out%.*}"
    esac
}

decompress() {
    case ${1##*.} in
        xz|txz) xz -qdcT 0 ;;
        gz|tgz) gunzip -qdc ;;
        bz2|tbz) bunzip2 -qdc
    esac <"$1"
}

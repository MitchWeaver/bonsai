#!/bin/sh
#
# http://github.com/mitchweaver/bore
#
# package manager for [NAME] Linux
#

die() { >&2 echo "$@" ; exit 1 ; }

usage() {
cat << EOF
bore pkg mgr

commands:
-----------
add    | -a
del    | -d
search | -s
list   | -l
isinst | -i
count  | -c
EOF
exit
}

sortdb() { [ -f "$boredb" ] && sort -o "$boredb" "$boredb" ; }

clean() {
    [ -d "$work" ] && rm -rf "$work"/*
    # remove empty dirs in $opt
    for dir in $(find "$opt" -type d ! -wholename "$opt" 2> /dev/null) ; do
        rmdir "$dir" 2> /dev/null
    done
    sortdb
}

getcc() {
    [ -z "$cc" ] && cc="$gcc"
    [ "$bootstrap_cc" ] && cc="$bootstrap_cc"
}

cc() { $cc "$@" ; }

# macros for convenience when dealing with borked makefiles:
# add includes/libs coming with pkg to search paths
include_pkg_headers() {
    for dir in $(find -type d) ; do
        PKG_INCLUDES="$PKG_INCLUDES -I$dir"
    done
    CFLAGS="$CFLAGS $PKG_INCLUDES"
}
link_pkg_libs() {
    for dir in $(find -type d) ; do
        PKG_LIBS="$PKG_INCLUDES -L$dir"
    done
    LDFLAGS="$PKG_LIBS $LDFLAGS"
}

getflags() {
    # If we are bootstrapping, all of our created symlinks
    # will be non-functional. This is because they will be
    # pointing to, for example, "/lib" instead of "$chroot/lib".
    # As a fix for this, we will find and include every $pkg/lib.
    if [ "$chroot_root" ] ; then
        for pkg in $(ls $root/opt) ; do
            [ -d $root/opt/$pkg/lib ] &&
                LDFLAGS="$LDFLAGS -L$root/opt/$pkg/lib"
            if [ -d $root/opt/$pkg/include ] ; then
                CFLAGS="$CFLAGS -I$root/opt/$pkg/include"
                CPPFLAGS="$CPPFLAGS -I$root/opt/$pkg/include"
            fi
        done
    fi

    # note: flag order DOES matter, edit with caution
    LDFLAGS="-static --static -Wl,--gc-sections $LDFLAGS $ldflags"
    CFLAGS="-static --static -fdata-sections -ffunction-sections $CFLAGS $cflags"
    CPPFLAGS="-static --static $CPPFLAGS $cppflags"
    CXXFLAGS="-static --static $CXXFLAGS $cxxflags"
    PKG_CONFIG="pkg-config --static"
    export GREP=$(which grep) SED=$(which sed) AWK=$(which awk)
}

patch() { for p ; do command patch -p0 < "$p" > /dev/null ; done ; }

configure() {
    ! $docs  && local _docs="--disable-docs \
                             --disable-gtk-docs \
                             --disable-gtk-docs-html"
    ! $nls   && local _nls='--disable-nls'
    ! $debug && local _debug='--disable-debug --disable-debugger'

    # try to enable as many options as possible
    # if they are allowed in the configure script
    local allowed=""
    local tmp_help=$(mktemp)
    ./configure --help > $tmp_help
    for flag in --static --enable-static --enable-static-link \
                --disable-rpath --disable-option-checking --without-tests \
                $quiet $debug $_nls $_docs ; do
        grep -- "$flag" $tmp_help > /dev/null && \
            allowed="$allowed $flag"
    done
    if grep -- --enable-shared $tmp_help > /dev/null ; then
        allowed="$allowed --disable-shared"
    fi
    rm -f $tmp_help

    CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        CXXFLAGS="$CXXFLAGS" ./configure $allowed "$@" > /dev/null

 # PREFIX="$opt"/$name prefix="$opt"/$name --prefix="$opt"/$name 
}

make() {
    ! $mans && local _docs="MANPREFIX=/dev/null"
    $quiet  && local _quiet='-s'
    command make $makeflags CC="$cc" CFLAGS="$CFLAGS" \
        LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        -j$jobs prefix="$opt/$name" PREFIX="$opt/$name" \
        $_docs $_quiet "$@" > /dev/null
}

# helper to get around all things that GNU does wrong with packaging
GNU_sucks() {
    # GNU programs have the most insane dependency tracking I have ever seen.
    # To check for dependencies, they often simply try to run the program
    # and if it has a -gt 0 exit code, the dependency must not be in $PATH.
    #
    # This breaks all kinds of things, namely if we are running under `set -e`
    # As a workaround, just manually track depedencies -- clear the file.
    [ -f build-aux/missing ] && :> build-aux/missing
}

run_build() {
    getcc
    getflags
    GNU_sucks
    has() { type $1 | grep 'is.*.function' > /dev/null ; return $? ; }
    # run user defined prebuild(), if exists
    if has prebuild ; then
        prebuild || die "$name prebuild() failed"
    fi
    # run user defined build(), if exists
    if has build ; then
        build || die "$name build() failed"
    else
        { # if build() wasn't defined, try to build generically
          [ -f ./configure ] && configure
          make
          make install
        } || die "$name generic build() failed"
    fi
    # run user defined postbuild(), if exists
    if has postbuild ; then
        postbuild || die "$name postbuild() failed"
    fi
    unset -f has
}

addpkg() {
    name=$1
    pkgfile="$ports"/$name/pkgfile

    if [ -f "$pkgfile" ] ; then
        . "$pkgfile"
    else
        die "Error: can't source $name's pkgfile?"
    fi
    [ "$(ls $boredb | wc -l)" -gt 0 ] || die "no ports found"
    isinst $name > /dev/null && die "port $name is already installed"

    [ -z "$version" ] && version='1.0'
    pkgid="${name}${delim}${version}"
    pkgdir="$work"/"$pkgid"

    # download/extract package
    get "$source"
    cd "$pkgdir" || die "Error: unable to cd to $pkgdir"

    echo ". building $name..."
    mkdir -p $opt/$name

    if run_build ; then
        rm -rf "$pkgdir"
        create_symlinks $name
        clear_junk $name
        echo "$pkgid" >> "$boredb"
        echo "$name installed!"
        clean
    fi
}

# downloads a given url and extracts to $work
get() {
    [ $# -lt 1 ] && die 'get(): no source given'
    clean # clean $work, incase bore was interrupted
    local url="$1"
    local tmp=$(mktemp -d)

    mkdir -p "$pkgdir" "$sources"
    cd "$sources"

    if [ "$version" = git ] ; then
        if [ ! -d "$pkgid" ] ; then
            echo ". cloning $1..."
            git clone $git_opts "$url" $tmp || die "get(): could not clone $url"
            mv -f "$tmp"/* "$work"/"$pkgid"
            $keep_tarballs && cp -rf "$work"/"$pkgid" "$sources"/"$pkgid"
        else
            cp -rf "$sources"/"$pkgid" "$work"
        fi
    else # we are downloading with curl

        if [ ! -f "$pkgid" ] ; then
            echo ". downloading $1..."
            curl -q -L -C - $curl_opts -o "$pkgid" --url "$url" ||
                die "get(): could not download $name"
            cp -f "$pkgid" $tmp
        else
            cp -f "$pkgid" $tmp
        fi

        case $(file $tmp/*) in
            *tgz*)   local ext=tgz   ;;
            *'gzip comp'*)  local ext=gz    ;;
            *'bzip2 comp'*) local ext=bzip2 ;;
            *'XZ comp'*)    local ext=xz    ;;
            *) die "get(): could not discern compression type of $name"
        esac

        # decompressors bug out if no extension...
        mv -f $tmp/* $tmp/${name}.${ext}

        case $ext in
            xz)     xz      -d $tmp/* ;;
            gz|tgz) gunzip  -d $tmp/* ;;
            bz2)    bunzip2 -d $tmp/* ;;
            *) die "get(): unknown compression algorithm"
        esac
        [ $? -gt 0 ] && die "get(): failed to decompress $name"

        if file $tmp/* | grep 'tar archive' > /dev/null ; then
            ext=tar.${ext}
            mv $tmp/* $tmp/${name}.tar
            tar -xf $tmp/${name}.tar -C $tmp/ || 
                die "get(): tar could not extract $pkgid.$ext"       
        fi

        ! $keep_tarballs && rm -f "$sources"/"$pkgid" 

        mv -f $tmp/*/* "$work"/"$pkgid" ||
            die "get(): failed to move unpacked tarball"
    fi
    rm -rf $tmp
    # copy all port's files, except its pkgfile
    for file in $(ls -A "$ports"/"$name"/* | grep -v pkgfile) ; do
        cp -f "$file" "$pkgdir"
    done
}

# creates symlinks for a port
create_symlinks() {
    local name=$1
    cd "$src"
    cd ..
    echo '. creating symlinks...'
    for dir in bin sbin share include etc lib libexec ; do
        # recursively create pkg subdirectories in
        # equivalent /root subdirectories
        # example: $pkg/lib/pkgconfig -> /lib/pkgconfig
        find "$opt"/$name/$dir ! -path "*$dir" ! -path "*share/*man*" -type d 2> /dev/null | while read -r subdir ; do
            mkdir -p "${subdir#$opt/$name/}"
        done
        # recursively link all files
        # example: $pkg/include/asm/*.h -> /include/asm/*.h
        find "$opt"/$name/$dir ! -path "*share/*man*" -type f -o -type l 2> /dev/null | while read -r file ; do
            file="${file#$opt/$name/}"
            # important: this is /opt not $opt !
            ln -sf "/opt/$name/$dir/${file##*/}" ./$file
        done
    done
    $mans && # only link mans if config boolean is true
        if [ -d "$opt"/$name/share/man ] ; then
            for manX in $(seq -f "man%g" -s " " 1 8) ; do
                find "$opt"/$name/share/man/$manX ! -path "*/$manX" 2> /dev/null | while read -r man ; do
                    man="${man#$opt/$name/}"
                    ln -sf "/opt/$name/share/man/$manX/${man##*/}" "$man"
                done
            done
        fi
}

clear_junk() {
    [ -d "$opt"/$1/share/info ] && rm -r "$opt"/$1/share/info
    if ! $docs && [ -d "$opt"/$1/share/doc ] ; then
        rm -r "$opt"/$1/share/doc
    fi
    if ! $mans && [ -d "$opt"/$1/share/man ] ; then
        rm -r "$opt"/$1/share/man
    fi
}

delpkg() {
    local name="$1"
    grep "$name" "$boredb" > /dev/null 2>&1 || die "$name is not installed"

    FOLDERS=""
    FILES=""

    for i in $(find "$opt"/$name ! -name "$opt"/$name) ; do
        if [ -d "$i" ] ; then
            FOLDERS="$FOLDERS $i"
        else
            FILES="$FILES $i"
        fi
    done

    echo "folders: $FOLDERS"
    echo "files: $FILES"

    # checks if "$1" is a symlink 
    # and its target still exists
    # test_link() {
    #     if [ -L "$1" ] ; then
    #         [ -e "$1" ] || return 1
    #     fi
    #     return 0
    # }

    # the pkg's data has already been deleted
    # but now we must remove all of its symlinks
    # for dir in bin share include etc lib ; do
    #     for i in `find "$prefix/$dir" ! -path "$prefix/$dir"` ; do
    #         test_link "$i" || rm -f "$i"
    #     done
    # done

    [ -d "$opt/$name" ] && rm -rf "$opt/$name"

    local tmp=$(mktemp)
    sed -e "s/${name}${delim}.*//" -e '/^$/d' "$boredb" > $tmp
    cat $tmp > "$boredb"
    rm -f $tmp
    clean

    echo "$name deleted"
}

search() {
    [ "$1" ] || die 'search: no argument given'
    local results="$(find "$ports" ! -path "$ports" -name *${1}* | sort)"
    [ "$results" ] || die "port $1 not found"
    for port in $results ; do
        port=${port##*/}
        echo ${port%.*}
    done
}

isinst() {
    [ "$1" ] || die 'isinst: no argument given'
    result=$(grep -i -- "$1" "$boredb")
    if [ "$result" ] ; then
        echo "port $result is installed"
        return 0
    else
        echo "port $1 is not installed"
        return 1
    fi
}

loadconfig() {
    # Warning: These options are used when bootstrapping a system.
    #          ... calling them otherwise is not recommended.
    for arg in "$@" ; do
        case "$arg" in
            --root=*) chroot_root="${arg#--root=}" ;;
            --cc=*)   bootstrap_cc="${arg#--cc=}"
        esac
    done

    if [ -z "$chroot_root" ] ; then
        . /src/bore.rc || die "Error: Could not source /src/bore.rc"
    else
        chroot_bore_rc=$(mktemp)
        cp -f "$chroot_root"/src/bore.rc "$chroot_bore_rc" || 
            die "Error: could not load $chroot_src/bore.rc"

        sed -i "s|^root=.*|root=$chroot_root|" "$chroot_bore_rc"

        . "$chroot_bore_rc"
        rm -f "$chroot_bore_rc"
    fi

    [ -z "$jobs" ] && jobs=1
    [ -f "$boredb" ] || :> "$boredb"

    # todo: find a way to loop through config and check every var
    [ "$root" ]   || die "loadconfig(): \$root failed to set"
    [ "$src" ]    || die "loadconfig(): \$src failed to set"
    [ "$opt" ]    || die "loadconfig(): \$opt failed to set"
    [ "$bore" ]   || die "loadconfig(): \$bore failed to set"
    [ "$boredb" ] || die "loadconfig(): \$boredb failed to set"
    [ "$delim" ]  || die "loadconfig(): \$delim failed to set"
}

main() {
    loadconfig "$@"

    while [ $# -gt 0 ] ; do
        case "$1" in
            add|-a)    addpkg $2 ; exit $? ;;
            del|-d)    delpkg $2 ; exit $? ;;
            search|-s) search $2 ; exit $? ;;
            isinst|-i) isinst $2 ; exit $? ;;
            list|-l)   cat "$boredb" ; exit $? ;;
            count|-c)  cat "$boredb" | wc -l | sed 's/ //' ; exit ;;
            --cc=*|--root=*) shift ;; # see above
            *help|-h)  usage ;;
            *) if [ "$1" ] ; then
                   addpkg $1
                   exit $?
               else
                   usage
               fi
        esac
    done
}

main "$@"

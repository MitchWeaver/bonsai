# runs build() method inside a pkgfile
# params: pkgname
run_build() {
    getcc
    getflags
    GNU_sucks

    if defined prebuild ; then
        name=$1 prebuild || die "$1 prebuild() failed"
    else # else, try to apply any patches (convenience)
        patch || die "$1 generic prebuild() failed"
    fi
    # run user defined build(), if exists
    if defined build ; then
        name=$1 build || die "$1 build() failed"
    else
        name=$1 generic_build || die "$1 generic build() failed"
    fi
    # run user defined postbuild(), if exists
    if defined postbuild ; then
        name=$1 postbuild || die "$1 postbuild() failed"
    fi
}

# return $cc if not user specified
getcc() { [ -z "$cc" ] && cc="$gcc" ; }
# convenience function
cc() { $cc "$@" ; }

# macros for convenience when dealing with borked makefiles:
# add includes/libs coming with pkg to search paths
# params: none, but assumes being withinside $work/$pkgname
include_pkg_headers() {
    for dir in $(find . -type d) ; do
        PKG_INCLUDES="$PKG_INCLUDES -I$dir"
    done
    CFLAGS="$CFLAGS $PKG_INCLUDES"
    unset dir
}
link_pkg_libs() {
    for dir in $(find . -type d) ; do
        PKG_LIBS="$PKG_INCLUDES -L$dir"
    done
    LDFLAGS="$PKG_LIBS $LDFLAGS"
    unset dir
}

getflags() {
    # If we are bootstrapping, all of our created symlinks
    # will be non-functional. This is because they will be
    # pointing to, for example, "/lib" instead of "$chroot/lib".
    # As a fix for this, we will find and include every $pkg/lib.
    if [ "$BOOTSTRAP" ] ; then
        for pkg in $(ls "$pkgs") ; do
            [ -d "$pkgs"/$pkg/lib ] &&
                LDFLAGS="$LDFLAGS -L"$pkgs"/$pkg/lib"
            if [ -d "$pkgs"/$pkg/include ] ; then
                CFLAGS="$CFLAGS -I"$pkgs"/$pkg/include"
            fi
        done
    fi

    LDFLAGS="$LDFLAGS $ldflags"
    CFLAGS="$CFLAGS $cflags"
    CPPFLAGS="$CPPFLAGS $cppflags"
    CXXFLAGS="$CXXFLAGS $cxxflags"
    PKG_CONFIG="$pkgcfgflags"
    unset pkg
}

# convenience function, tries to find all *.patch
# in $work/$pkgname directory and apply them
patch() {
    find . -type f -name "*.patch" | while read -r patch ; do
        command patch -p0 < "$patch"
    done
    unset patch
}

configure() {
    ! $docs  && _docs="--disable-docs \
                             --disable-gtk-docs \
                             --disable-gtk-docs-html"
    ! $nls   && _nls='--disable-nls'
    ! $debug && _debug='--disable-debug --disable-debugger'

    # try to enable as many options as possible
    # if they are allowed in the configure script
    allowed=""
    tmp_help=$(mktemp)
    ./configure --help > $tmp_help
    for flag in --static --enable-static --enable-static-link \
                --disable-rpath --disable-option-checking --without-tests \
                $quiet $debug $_nls $_docs ; do
        grep -- "$flag" $tmp_help > /dev/null && allowed="$allowed $flag"
    done
    if grep -- --enable-shared $tmp_help > /dev/null ; then
        allowed="$allowed --disable-shared"
    fi
    rm -f $tmp_help

    CC="$cc" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" \
        CXXFLAGS="$CXXFLAGS" PREFIX="$pkgs/$pkgname" prefix="$pkgs/$pkgname" \
        ./configure --prefix="$pkgs/$pkgname" $allowed "$@" > /dev/null
    unset allowed flag tmp_help _docs _nls _debug
}

make() {
    ! $mans && _docs="MANPREFIX=/dev/null"
    $quiet  && _quiet='-s'
    CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" CXXFLAGS="$CXXFLAGS" \
        command make $makeflags -j$jobs $_docs $_quiet \
        CC="$cc" PREFIX="$pkgs/$pkgname" prefix="$pkgs/$pkgname" "$@" > /dev/null
    unset _docs _quiet
}

# run if pkgfile doesn't define a custom build()
generic_build() {
    [ -f configure ] && configure
    make
    make install
}

# helper to get around all things that GNU does wrong with packaging
GNU_sucks() {
    # GNU programs have the most insane dependency tracking I have ever seen.
    # To check for dependencies, they often simply try to run the program
    # and if it has a -gt 0 exit code, the dependency must not be in $PATH.
    #
    # This breaks all kinds of things, namely if we are running under `set -e`
    # As a workaround, just manually track depedencies -- clear the file.
    [ -f build-aux/missing ] && :> build-aux/missing
    #
    # Some GNU makefiles test certain program flags to see if they
    # are GNU coreutils programs. Some of our minimal programs fail this,
    # causing the makefile to abort unless $ENV variables are set. Absurd.
    # Should a makefile not work correctly with our coreutils, 
    # it will be patched on a per-port basis.
    export GREP=$(which grep) SED=$(which sed) AWK=$(which awk)
}

# remove junk files
# params: $pkgname
clear_junk() {
    [ -d "$pkgs"/$1/share/info ] && rm -r "$pkgs"/$1/share/info
    if ! $docs && [ -d "$pkgs"/$1/share/doc ] ; then
        rm -r "$pkgs"/$1/share/doc
    fi
    if ! $mans && [ -d "$pkgs"/$1/share/man ] ; then
        rm -r "$pkgs"/$1/share/man
    fi
}
